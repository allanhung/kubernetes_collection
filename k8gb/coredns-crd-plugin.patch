diff --git a/Dockerfile b/Dockerfile
index 7e32298..1b8554a 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -1,4 +1,14 @@
+ARG ARCH="amd64"
+ARG OS="linux"
+
+FROM golang:1.20 AS build
+ENV CGO_ENABLED=0
+RUN apt-get update && apt-get install -y patch
+WORKDIR /go/src/github.com/allanhung/coredns-crd-plugin
+COPY . /go/src/github.com/allanhung/coredns-crd-plugin
+RUN make build
+
 FROM alpine:3.14.2
-COPY coredns /
+COPY --from=build /go/src/github.com/allanhung/coredns-crd-plugin/coredns /
 EXPOSE 53 53/udp
 ENTRYPOINT ["/coredns"]
diff --git a/common/k8sctrl/ctrl.go b/common/k8sctrl/ctrl.go
index 0351b3c..0a65e00 100644
--- a/common/k8sctrl/ctrl.go
+++ b/common/k8sctrl/ctrl.go
@@ -138,11 +138,12 @@ func endpointHostnameIndexFunc(obj interface{}) ([]string, error) {
 }
 
 func (ctrl *KubeController) getEndpointByName(host string, clientIP net.IP) (lep LocalDNSEndpoint) {
+	queryHost := strings.ToLower(host)
 	log.Infof("Index key %+v", host)
-	objs, _ := ctrl.epc.GetIndexer().ByIndex(endpointHostnameIndex, strings.ToLower(host))
+	objs, _ := ctrl.epc.GetIndexer().ByIndex(endpointHostnameIndex, queryHost)
 	for _, obj := range objs {
 		ep := obj.(*endpoint.DNSEndpoint)
-		lep = extractLocalEndpoint(ep, clientIP, host)
+		lep = extractLocalEndpoint(ep, clientIP, queryHost)
 		if !lep.isEmpty() {
 			break
 		}
diff --git a/service/gateway/gateway.go b/service/gateway/gateway.go
index 9c9a8c3..40f1244 100644
--- a/service/gateway/gateway.go
+++ b/service/gateway/gateway.go
@@ -31,6 +31,9 @@ import (
 	clog "github.com/coredns/coredns/plugin/pkg/log"
 	"github.com/coredns/coredns/request"
 	"github.com/miekg/dns"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/client-go/kubernetes"
+	"k8s.io/client-go/rest"
 	"sigs.k8s.io/external-dns/endpoint"
 )
 
@@ -148,6 +151,35 @@ func (gw *Gateway) TXT(state request.Request, results []string, ttl endpoint.TTL
 	return append(records, &dns.TXT{Hdr: dns.RR_Header{Name: state.Name(), Rrtype: dns.TypeTXT, Class: dns.ClassINET, Ttl: uint32(ttl)}, Txt: results})
 }
 
+func (gw *Gateway) CoreDNSExposedIPs() ([]string, error) {
+	result := []string{}
+	config, err := rest.InClusterConfig()
+	if err != nil {
+		return nil, err
+	}
+
+	// creates the clientset
+	clientset, err := kubernetes.NewForConfig(config)
+	if err != nil {
+		return nil, err
+	}
+	// get services
+	services, err := clientset.CoreV1().Services(gw.opts.servicens).List(context.TODO(), metav1.ListOptions{
+		LabelSelector: metav1.FormatLabelSelector(metav1.SetAsLabelSelector(gw.opts.servicelabel)),
+	})
+	if err != nil {
+		return nil, err
+	}
+
+	for _, service := range services.Items {
+		if service.Spec.Type == "LoadBalancer" {
+			result = append(result, service.Status.LoadBalancer.Ingress[0].IP)
+			log.Infof("Service Name: %s, IP: %s", service.Name, service.Status.LoadBalancer.Ingress[0].IP)
+		}
+	}
+	return result, nil
+}
+
 func (gw *Gateway) selfAddress(state request.Request) (records []dns.RR) {
 	// TODO: need to do self-index lookup for that i need
 	// a) my own namespace - easy
@@ -161,7 +193,11 @@ func (gw *Gateway) selfAddress(state request.Request) (records []dns.RR) {
 	}
 
 	var ep = k8sctrl.Resources.DNSEndpoint.Lookup(index, net.ParseIP(state.IP()))
+	IPs, err := gw.CoreDNSExposedIPs()
+	if err != nil {
+		log.Errorf("Get CoreDNS Exposed IP error, %v", err)
+	}
 	m := new(dns.Msg)
 	m.SetReply(state.Req)
-	return gw.A(state, netutils.TargetToIP(ep.Targets), ep.TTL)
+	return gw.A(state, netutils.TargetToIP(IPs), ep.TTL)
 }
diff --git a/service/gateway/opts.go b/service/gateway/opts.go
index 0d87178..ec32d7c 100644
--- a/service/gateway/opts.go
+++ b/service/gateway/opts.go
@@ -18,13 +18,19 @@ limitations under the License.
 Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
 */
 
+import (
+	"os"
+)
+
 type Opts struct {
-	annotation string
-	apex       string
-	hostmaster string
-	ttlLow     uint32
-	ttlHigh    uint32
-	zones      []string
+	annotation   string
+	apex         string
+	hostmaster   string
+	ttlLow       uint32
+	ttlHigh      uint32
+	zones        []string
+	servicens    string
+	servicelabel map[string]string
 }
 
 var (
@@ -34,7 +40,7 @@ var (
 	defaultHostmaster = "hostmaster"
 )
 
-func NewGatewayOpts(annotation, apex string, ttlLow, ttlHigh uint32, zones []string) Opts {
+func NewGatewayOpts(annotation, apex string, ttlLow, ttlHigh uint32, zones []string, servicens string, servicelabel map[string]string) Opts {
 	opts := Opts{
 		apex:       defaultApex,
 		ttlLow:     ttlLowDefault,
@@ -52,5 +58,11 @@ func NewGatewayOpts(annotation, apex string, ttlLow, ttlHigh uint32, zones []str
 	}
 	opts.annotation = annotation
 	opts.zones = zones
+	if len(servicens) != 0 {
+		opts.servicens = servicens
+	} else {
+		opts.servicens = os.Getenv("POD_NAMESPACE")
+	}
+	opts.servicelabel = servicelabel
 	return opts
 }
diff --git a/setup.go b/setup.go
index ebdc49d..1ef6388 100644
--- a/setup.go
+++ b/setup.go
@@ -21,6 +21,7 @@ Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
 import (
 	"fmt"
 	"strconv"
+	"strings"
 
 	"github.com/AbsaOSS/k8s_crd/service/gateway"
 	"github.com/AbsaOSS/k8s_crd/service/wrr"
@@ -40,6 +41,8 @@ type args struct {
 	negttl         uint32
 	ttl            uint32
 	zones          []string
+	servicens      string
+	servicelabel   map[string]string
 }
 
 const thisPlugin = "k8s_crd"
@@ -62,7 +65,7 @@ func setup(c *caddy.Controller) error {
 	if err != nil {
 		return plugin.Error(thisPlugin, err)
 	}
-	gwopts := gateway.NewGatewayOpts(rawArgs.annotation, rawArgs.apex, rawArgs.ttl, rawArgs.negttl, rawArgs.zones)
+	gwopts := gateway.NewGatewayOpts(rawArgs.annotation, rawArgs.apex, rawArgs.ttl, rawArgs.negttl, rawArgs.zones, rawArgs.servicens, rawArgs.servicelabel)
 	_ = k8sCRD.container.Register(gateway.NewGateway(gwopts))
 	if rawArgs.loadbalance == weightRoundRobin {
 		_ = k8sCRD.container.Register(wrr.NewWeightRoundRobin())
@@ -123,6 +126,20 @@ func parse(c *caddy.Controller) (args, error) {
 			case "loadbalance":
 				log.Infof("loadbalance: %+v", args)
 				a.loadbalance = args[0]
+			case "servicens":
+				log.Infof("servicens: %+v", args)
+				a.servicens = args[0]
+			case "servicelabel":
+				log.Infof("servicelabel: %+v", args)
+				servicelabel := make(map[string]string)
+				pairs := strings.Split(args[0], ",")
+				for _, pair := range pairs {
+					keyValue := strings.Split(pair, "=")
+					key := strings.TrimSpace(keyValue[0])
+					value := strings.TrimSpace(keyValue[1])
+					servicelabel[key] = value
+				}
+				a.servicelabel = servicelabel
 			default:
 				return a, c.Errf("Unknown property '%s'", c.Val())
 			}
